#include "app/ecat_app.h"
#include "cia402/cia402.h"

#include "esc_soes.h"
#include "ecat_slv.h"
#include "Inc/utypes.h"

//#include "usart.h"
//#include "esc_irq.h"
//#include "pdo_override.h"



/* CANopen Object Dictionary */
_Objects    Obj;


/* CiA402 motion control configuration */
void AppCia402Init();
void AppCia402Mc();

cia402_axis_t cia402axis =
{
    .init_od_hook = AppCia402Init,
    .motion_control_hook = AppCia402Mc
};

/* CiA402 hooks declarations */
void AppCia402Init()
{
    /* Match CiA 402 objects to used CoE Object Dictionary implementation */
    cia402axis.statusword = &Obj.Status_Word;
    cia402axis.ALstatus = &ESCvar.ALstatus;
}

void AppCia402Mc()
{
    // TODO motion control here
    Obj.Position_actual = Obj.Target_position; // dummy loopback

    // csp is the only supported mode for now
    *(cia402axis.statusword) |= CIA402_STATUSWORD_CSP_DRIVE_FOLLOWS_COMMAND;
}



uint16_t CheckDcHandler(void)
{
    // minimum watchdog value is 1 ms, in nanoseconds
    #define MIN_WATCHDOG_VALUE_NS      1000000

    /* Indicate we run DC */
    ESCvar.dcsync = 1;
    /* Fetch the sync counter limit (SDO10F1) */
    ESCvar.synccounterlimit = Obj.ErrorSettings.SyncErrorCounterLimit;

//    uint32_t sync0cycleTime = ESC_enable_DC();
//
//    Obj.Sync_Manager_2_Parameters.CycleTime = sync0cycleTime;
//
//    // Obj.Sync_Manager_3_Parameters.CycleTime = sync0cycleTime;
//    // calculate watchdog value as 2 x SYNC0 cycle time
//    int watchdog_value = 2 * sync0cycleTime;
//    if (watchdog_value < MIN_WATCHDOG_VALUE_NS)
//    {
//        watchdog_value = MIN_WATCHDOG_VALUE_NS;
//    }
//    APP_setwatchdog(watchdog_value);

    return 0;
}

void EcatApp()
{
    cia402_state_machine(&cia402axis, Obj.Control_Word);
}

/* SOES configuration */
static esc_cfg_t config = {
    .user_arg = "ax58100",
    .use_interrupt = 1,
    .watchdog_cnt = INT32_MAX,
    .set_defaults_hook = NULL,
    .pre_state_change_hook = NULL,
    .post_state_change_hook = NULL,
    .application_hook = EcatApp,
    .safeoutput_override = NULL,
    .pre_object_download_hook = NULL,
    .post_object_download_hook = NULL,
//    .rxpdo_override = rxpdo_override,
//    .txpdo_override = txpdo_override,
//    .esc_hw_interrupt_enable = ESC_interrupt_enable,
//    .esc_hw_interrupt_disable = ESC_interrupt_disable,
    .esc_hw_eep_handler = NULL,
    .esc_check_dc_handler = CheckDcHandler,
};

void EcatAppInit(void) {
    ecat_slv_init(&config);
    cia402_init(&cia402axis);
//	init_override();
}


void EcatAppLoop(void)
{
//    // stack in mixed mode
//    if (sync0_irq_flag)
//    {
//        ESC_updateALevent();
//        DIG_process (DIG_PROCESS_APP_HOOK_FLAG | DIG_PROCESS_INPUTS_FLAG);
//        sync0_irq_flag = 0;
//    }
//
//    if (pdi_irq_flag)
//    {
//        ESC_updateALevent();
//        if (ESCvar.dcsync)
//        {
//            DIG_process (DIG_PROCESS_OUTPUTS_FLAG);
//        } else
//        {
//            DIG_process (DIG_PROCESS_OUTPUTS_FLAG | DIG_PROCESS_APP_HOOK_FLAG | DIG_PROCESS_INPUTS_FLAG);
//        }
//        pdi_irq_flag = 0;
//    }
//    else
//    {
//        // ecat_slv_worker(ESCREG_ALEVENT_CONTROL | ESCREG_ALEVENT_SMCHANGE
//        //                 | ESCREG_ALEVENT_SM0 | ESCREG_ALEVENT_SM1);
//        ecat_slv_poll();
//        DIG_process(DIG_PROCESS_WD_FLAG);
//    }
}

uint32_t EcatApp_Benchmark_Us()
{
//    // benchmark start
//    stopwatch_t st;
//    stopwatch_start(&st);
//
//    EcatAppLoop();
//
//    // benchmark stop
//    volatile uint32_t elapsed_us = stopwatch_now_us(&st);
//    static volatile uint32_t hiscore = 0;
//
//    if (elapsed_us > hiscore)
//    {
//        hiscore = elapsed_us;
//    }
//
//    if (STM_EVAL_IsPressed())
//    {
//        printf("PDI irq = %s \r\n", HEX4B(pdi_irq_flag));
//    }
//
//    return elapsed_us;
}



void cb_get_inputs()
{
    /* SOES reqires this function but nothing to do here in CiA402 app */
}


void cb_set_outputs()
{
    /* SOES reqires this function but nothing to do here in CiA402 app */
}


